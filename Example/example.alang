// 示例总览：按章节展示 ALang 的核心能力
// 提示：脚本末尾会打印结束语；CLI 主程序随后会调用 runEventLoopUntilIdle() 排空事件循环，
// 以便看到 then/catch 和 go 的异步输出结果。

// 1) 变量、函数与基础算术
println("== 变量、函数与算术运算 ==");
function add(a, b) {
    return a + b;
}
let x = 10;
let y = 90;
println("求和结果: ${add(x, y)}");

// 2) 循环与条件：while 与 if/else
println("");
println("== 循环与条件判断 ==");
let i = 0;
let acc = 0;
while (i < 5) {
    acc = acc + i;
    i = i + 1;
}
if (acc >= 10) {
    println("累加结果: ${acc}");
} else {
    println("累加结果（较小）: ${acc}");
}

// 3) 数组与对象：下标赋值、属性访问、计算属性名
println("");
println("== 数组与对象 ==");
let arr = [1, 2, 3];
arr[1] = 42;
println("数组 arr: ${arr}");

let obj = { a: 1, b: "hi" };
println("对象属性 obj.a: ${obj.a}");
obj["c"] = 7;
println("对象 obj: ${obj}");

let key = "dyn";
let o2 = {
    [key]: 1,
    x: 2
};
println("计算属性名: dyn=${o2.dyn}, x=${o2.x}");

// 4) for / break / continue：跳过与提前退出
println("");
println("== for 循环 / break / continue ==");
let s = 0;
for (let k = 0; k < 10; k = k + 1) {
    if (k == 3) continue; // 跳过 k=3 的迭代
    if (k == 8) break;    // k=8 时提前终止循环
    s = s + k;
}
println("for 循环累加结果: ${s}");

// 5) 方法风格内置功能：len()（长度）/ push()（数组添加）
// 说明：字符串、数组、对象均支持 len 方法
println("");
println("== 内置方法：len / push ==");
let s2 = "hello";
println("字符串长度 s2.len(): ${s2.len()}");

let a2 = [1, 2];
a2.push(3);
println("数组 a2: ${a2}, 数组长度 a2.len(): ${a2.len()}");

// 6) 类、继承与扩展：使用 '<-' 语法实现继承；用 extends 扩展已有类的方法
println("");
println("== 类、继承与扩展 ==");
class Base {
    function constructor(v) {
        this.value = v;
    }

    function get() {
        return this.value;
    }
}

class Test <- Base { // Test 类继承 Base 类
    function inc() {
        this.value = this.value + 1; // 实例属性自增
    }
}

let t = new Test(5);
println("t.get(): ${t.get()}");
t.inc();
println("t 调用 inc() 后: ${t.get()}");
println("t.value: ${t.value}");

extends Test { // 扩展 Test 类，添加新方法
    function twice() {
        this.value = this.value * 2; // 实例属性翻倍
    }
}

let t2 = new Test(10);
t2.twice();
println("t2.value: ${t2.value}");

// 7) 接口与动态派发：interface 仅声明方法签名，可作为多继承的父类型参与方法查找
println("");
println("== 接口与动态派发 ==");
interface Inter {
    function ping(a); // 仅声明方法签名，无实现
}

class Base2 {
    function ping(a) {
        println("Base2.ping ${a}");
    }
}

class D <- (Base2, Inter) { // 多继承：Base2 类 + Inter 接口
    function pong() {
        println("D.pong");
    }
}

let d = new D();
d.ping(7);
d.pong();

// 8) Lambda（匿名函数表达式）：支持闭包与立即调用
println("");
println("== Lambda（匿名函数表达式） ==");
let triple = [](n) {
    return n * 3;
};
println("triple(7): ${triple(7)}");
println("匿名函数立即调用: ${(
    [](x) {
        return x + 5;
    }
)(10)}");

// 9) 异常处理：throw 抛出异常 / try...catch 捕获异常
// 说明：await 的拒绝（reject）也会抛异常，可被 catch 捕获（见异步章节）
println("");
println("== 异常处理：throw / try...catch ==");
try {
    throw "错误信息: bad";
    println("此语句不会执行f");
} catch (e) {
    println("捕获到异常: ${e}");
}

// 10) 字符串插值：在字符串中用 ${表达式} 内联任意表达式
println("");
println("== 字符串插值 ==");
println("A:${x}, B:${y}, 求和结果:${add(x,y)}");
println("内联对象属性: ${ {k: 1, y: 2}.k }");

// 11) 异步编程：async/await、Promise.then/catch 链式调用、go 投递任务到事件循环
println("");
println("== 异步编程：async / await / Promise / go ==");
async function task(v) {
    println("任务开始 task start ${v}");
    await sleep(50);
    println("任务完成 task done ${v}");
    return v * 2;
}
function onTask(r) {
    println("then 回调接收结果: ${r}");
}
let p = task(21);
p.then(onTask)
 .catch([](e) {
     println("then 回调捕获错误: ${e}");
     return 0;
 });

Promise.resolve(1)
    .then([](v) {
        return v + 10;
    })
    .then([](v) {
        println("链式调用中间值 v2: ${v}");
        return v;
    })
    .catch([](e) {
        println("链式调用捕获错误: ${e}");
        return 0;
    });

go task(5); // 将任务投递到事件循环执行（异步非阻塞）
println("(脚本执行结束，事件循环将触发等待中的异步任务)");