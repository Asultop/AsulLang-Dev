// FFI (Foreign Function Interface) Test - Windows Version
// This file tests calling C functions from dynamic libraries on Windows

import std.ffi.*;

println("=== FFI (Foreign Function Interface) Tests (Windows) ===\n");

// Test 1: Load msvcrt.dll and call basic functions
println("Test 1: Loading msvcrt.dll and calling strlen");
try {
    let libcPath = "msvcrt.dll"; // Windows C runtime
    let libc = dlopen(libcPath, RTLD_LAZY);
    
    // Get strlen function
    let strlenPtr = dlsym(libc, "strlen");
    
    // Call strlen("Hello, World!")
    let testStr = "Hello, World!";
    let len = call(strlenPtr, "int", testStr);
    println("strlen('", testStr, "') = ", len);
    
    if (len == 13) {
        println("✓ strlen test passed");
    } else {
        println("✗ strlen test failed: expected 13, got", len);
    }
    
    dlclose(libc);
} catch (error) {
    println("Note: msvcrt.dll test skipped");
    println("Error:", error);
}

// Test 2: Call abs() function
println("\nTest 2: Library loading and symbol resolution");
try {
    let libcPath = "msvcrt.dll";
    let libc = dlopen(libcPath, RTLD_NOW);
    
    let absPtr = dlsym(libc, "abs");
    
    println("✓ Successfully loaded msvcrt.dll and resolved abs symbol");
    
    dlclose(libc);
} catch (error) {
    println("Note: abs test skipped");
    println("Error:", error);
}

// Test 3: Call mathematical functions (sqrt is in msvcrt.dll on Windows)
println("\nTest 3: Calling sqrt() from msvcrt.dll");
try {
    let libcPath = "msvcrt.dll";
    let libc = dlopen(libcPath, RTLD_LAZY);
    
    let sqrtPtr = dlsym(libc, "sqrt");
    
    let result1 = call(sqrtPtr, "double", 16.0);
    let result2 = call(sqrtPtr, "double", 25.0);
    let result3 = call(sqrtPtr, "double", 100.0);
    
    println("sqrt(16) = ", result1);
    println("sqrt(25) = ", result2);
    println("sqrt(100) = ", result3);
    
    if (result1 == 4.0 && result2 == 5.0 && result3 == 10.0) {
        println("✓ sqrt() test passed");
    } else {
        println("✗ sqrt() test failed");
    }
    
    dlclose(libc);
} catch (error) {
    println("Note: sqrt test skipped");
    println("Error:", error);
}

// Test 4: Test RTLD constants
println("\nTest 4: Testing RTLD constants");
println("RTLD_LAZY =", RTLD_LAZY);
println("RTLD_NOW =", RTLD_NOW);
println("RTLD_GLOBAL =", RTLD_GLOBAL);
println("RTLD_LOCAL =", RTLD_LOCAL);
println("✓ RTLD constants defined");

// Test 5: Error handling
println("\nTest 5: Error handling with invalid library");
try {
    let invalidLib = dlopen("nonexistent_library.dll", RTLD_LAZY);
    println("✗ Should have thrown error for invalid library");
} catch (error) {
    println("✓ Correctly caught error for invalid library");
}

// Test 6: Error handling with invalid symbol
println("\nTest 6: Error handling with invalid symbol");
try {
    let libcPath = "msvcrt.dll";
    let libc = dlopen(libcPath, RTLD_LAZY);
    
    let invalidSym = dlsym(libc, "nonexistent_function_12345");
    println("✗ Should have thrown error for invalid symbol");
    
    dlclose(libc);
} catch (error) {
    println("✓ Correctly caught error for invalid symbol");
}

// Test 7: Multiple calls to same library
println("\nTest 7: Reference counting with multiple opens");
try {
    let libcPath = "msvcrt.dll";
    
    let libc1 = dlopen(libcPath, RTLD_LAZY);
    let libc2 = dlopen(libcPath, RTLD_LAZY);
    
    // Get the same function from both handles
    let strlenPtr1 = dlsym(libc1, "strlen");
    let strlenPtr2 = dlsym(libc2, "strlen");
    
    let testStr = "Test";
    let len1 = call(strlenPtr1, "int", testStr);
    let len2 = call(strlenPtr2, "int", testStr);
    
    if (len1 == 4 && len2 == 4) {
        println("✓ Multiple handles to same library work correctly");
    } else {
        println("✗ Multiple handles test failed");
    }
    
    // Close both handles
    dlclose(libc1);
    dlclose(libc2);
} catch (error) {
    println("Note: Multiple handles test skipped");
    println("Error:", error);
}

// Test 8: Symbol resolution verification
println("\nTest 8: Symbol resolution with strcmp");
try {
    let libcPath = "msvcrt.dll";
    let libc = dlopen(libcPath, RTLD_LAZY);
    
    let strcmpPtr = dlsym(libc, "strcmp");
    
    println("✓ Successfully resolved strcmp symbol");
    println("Note: String argument passing requires proper calling convention");
    println("      This simplified FFI works best with numeric types");
    
    dlclose(libc);
} catch (error) {
    println("Note: strcmp test skipped");
    println("Error:", error);
}

// Test 9: Platform-specific library paths
println("\nTest 9: FFI is platform-aware");
println("System: Windows");
println("Standard library paths:");
println("  - msvcrt.dll: Microsoft Visual C Runtime");
println("  - kernel32.dll: Windows kernel functions");
println("  - user32.dll: Windows user interface");
println("✓ Platform detection working");

println("\n=== Summary ===");
println("FFI provides:");
println("- dlopen(path, mode): Load dynamic libraries");
println("- dlsym(handle, symbol): Get function pointers");
println("- dlclose(handle): Close libraries");
println("- call(funcPtr, returnType, ...args): Call C functions");
println("");
println("Supported return types: void, int, double, pointer, string");
println("Maximum 6 arguments per call");
println("Reference counting for library handles");
println("");
println("Windows-specific notes:");
println("- Use .dll extension for Windows libraries");
println("- System DLLs (msvcrt.dll, kernel32.dll) are in system path");
println("- LoadLibrary/GetProcAddress used under the hood");
println("");
println("=== All FFI Tests Completed! ===");
